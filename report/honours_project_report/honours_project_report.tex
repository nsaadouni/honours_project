
% to choose your degree
% please un-comment just one of the following
\documentclass[bsc,frontabs,twoside,singlespacing,parskip,deptreport]{infthesis}     % for BSc, BEng etc.
% \documentclass[minf,frontabs,twoside,singlespacing,parskip,deptreport]{infthesis}  % for MInf

\usepackage{pdfpages}
\usepackage{float}% If comment this, figure moves to Page 2
\usepackage{subcaption}
\usepackage{tabulary}
\usepackage{listings}
%\usepackage{hyperref}


\begin{document}

\title{Finding Vulnerabilities in Low-Level Protocols}

\author{Nordine Saadouni}

% to choose your course
% please un-comment just one of the following
%\course{Artificial Intelligence and Computer Science}
%\course{Artificial Intelligence and Software Engineering}
%\course{Artificial Intelligence and Mathematics}
%\course{Artificial Intelligence and Psychology }   
%\course{Artificial Intelligence with Psychology }   
%\course{Linguistics and Artificial Intelligence}    
\course{Computer Science}
%\course{Software Engineering}
%\course{Computer Science and Electronics}    
%\course{Electronics and Software Engineering}    
%\course{Computer Science and Management Science}    
%\course{Computer Science and Mathematics}
%\course{Computer Science and Physics}  
%\course{Computer Science and Statistics}    

% to choose your report type
% please un-comment just one of the following
%\project{Undergraduate Dissertation} % CS&E, E&SE, AI&L
%\project{Undergraduate Thesis} % AI%Psy
\project{4th Year Project Report}

\date{\today}


\abstract{
Basic example of an abstract (this will be changed)\\

Smart cards are used commercially and within industry for authentication, encryption, decryption, signing and verifying data. This paper aims to look into how the smart card interacts with an application at the lower level. PKCS\#11 (public key cryptography system?) is the standard that is implemented at the higher level and then broken down into command/response pairs sent as APDU traffic to and from the smart card. It is the APDU low-level protocol that will be analysed to see if any vulnerabilities are present with regard to the smart cards tested.\\
}

\maketitle


\section*{Acknowledgements}
Acknowledgements go here.
% Myrto, Andriana, Parents
% MSC student? 

\tableofcontents

%\pagenumbering{arabic}

%---------------------------------------------------------------------------------------------------------------------------------------------------

\chapter{Introduction}
Smart-cards are formally known as integrated circuit cards (ICC), and are universally thought to be secure, tamper-resistant devices. They store and process, cryptographic keys, authentication and user sensitive data. They are utilised to preform operations where confidentiality, data integrity and authentication are key to the security of a system.\\

\noindent Smart-cards offer what seems to be more secure methods for using cryptographic operations. (And should still provide the same level of security that would be offered to un-compromised systems, compared to those that are compromised by an attacker). This is partly due to the fact that the majority of modern smart-cards have their own on-board micro-controller, to allow all of these operations to take place on the card itself, with keys that are unknown to the outside world and stored securely on the device. Meaning the only actor that should be able to preform such operations would need to be in possession of the smart-card and the PIN/password. In many industries, for applications such as, banking/ payment systems, telecommunications, healthcare and public sector transport, 
%\begin{itemize}
%\item Banking/ payment
%\item E-commerce
%\item Sim cards/ telecommunications
%\item Healthcare
%\item Public transport
%\end{itemize}
smart-cards are used due to the security they are believed to provide.\\


\noindent The most common API (application programming interface) that is used to communicate with smart-cards is the RSA defined PKCS\#11 (Public Key Cryptography Standard). Also known as 'Cryptoki' (cryptographic token interface, pronounced as 'crypto-key'). The standard defines a platform-independent API to smart-cards and hardware security modules (HSM). PKCS\#11 originated from RSA security, but has since been placed into the hands of OASIS PKCS\#11 Technical Committee to continue its work (since 2013). [reference wikipedia PKCS\#11].\\


% Note: decide on a figure to use here, 10 OR 15 years!
% This paragraph needs to be re-written!
\noindent In the previous 10-15 years, literature has shown a great deal of research has examined the PKCS\#11 API. But not much attention has been paid to that of the lower-level communication, in which the higher level API is broken down into. This is analogous to C code being complied down to binary data to be operated on by the CPU. In the same context, a PKCS\#11 function cannot be considered 'secure' without its corresponding APDU command/response pairs also being considered 'secure'. Much like the addition of two integers cannot be considered to be correct in a higher level lanugage such as C, unless the corresponding binary instructions sent to the CPU are correct as well. 

%---------------------------------------------------------------------------------------------------------------------------------------------------

\chapter{Background}

\section{PKCS\#11}

\subsection{Key Object}
\subsection{Attributes}
\subsection{Most Common Functions}


\section{ISO 7816}

\subsection{Command Structure}
\subsection{Response Structure}
\subsection{Inter-Industry/ Proprietary}
\subsection{Most Common Commands}
\subsection{File Structure}





%---------------------------------------------------------------------------------------------------------------------------------------------------

\chapter{Cryptographic Operations}

\section{Hash Function}

\noindent explain this in an overview term



\section{Asymmetric Encryption}

\noindent explain this in an overview term

\subsection{RSA}

\section{Symmetric Encryption}

\noindent explain this in an overview term

\subsection{DES}
\subsection{Triple DES}
\subsection{AES}

% might go against those headings and just list them in the explanations
\subsection{ECB Mode}
\subsection{CBC Mode}


\section{Message Authentication Codes}

\noindent explain what a message authentication code is, what its used for\\
\noindent (wikipedia have good diagrams and explanations of this!!)

\subsection{Hash Based - Message Authentication Codes (HMAC)}
\subsection{Cryptographic Based - Message Authentication Codes (CMAC)}

\section{One Time Passwords}

\noindent What is a one time password $\rightarrow$ what forms are there?

\subsection{Hash Based - One Time Passwords (HOTP)}
\subsection{Time Based - One Time Passwords (TOTP)}




%---------------------------------------------------------------------------------------------------------------------------------------------------

\chapter{Tools}

\section{PCSC-lite}

\section{Virtual Smart-Card}
This is the man in the middle attack\\
Need to explain how this works thoroughly

\section{Parsing $\rightarrow$ Scripts created for ease of reading}






%---------------------------------------------------------------------------------------------------------------------------------------------------

\chapter{Related Work / Literature Review}

This will be a brief chapter and will discuss all of the research I have conducted.\\
Mainly regarding PKCS\#11 API attacks due to the small amount of literature that is available for APDU level attacks
I shall also explain why some of the attacks are not able to be conducted on the particular card I am reviewing






%---------------------------------------------------------------------------------------------------------------------------------------------------

\chapter{PKCS\#11 Functions - APDU analysis}

Here I shall simply give a trace of each PKCS\#11, and give an analysis of each trace

\section{Initialization?}
Might be worth separating these!
\section{C\_login}
\begin{verbatim}
----- APDU command/response pair 1 -----
00000000: 00 A4 04 00 0C A0 00 00  01 64 4C 41 53 45 52 00  .........dLASER.
00000010: 01 00                                             ..

00000000: 90 00                                             ..


----- APDU command/response pair 2 -----
00000000: 80 A4 08 00 06 3F 00 30  00 EE EE                 .....?.0...

00000000: 90 00                                             ..


----- APDU command/response pair 3 -----
00000000: 00 B0 00 00 00                                    .....

00000000: 02 C0 07 00 00 0A 00 0F  00 01 02 C2 0A 00 04 10  ................
00000010: 00 00 00 00 00 00 00 02  C3 0A 00 04 10 00 00 00  ................
00000020: 00 00 00 00 02 C1 01 00  02 C5 04 00 00 00 00 02  ................
00000030: C6 04 00 00 00 00 02 C8  01 00 02 C9 01 33 02 CA  .............3..
00000040: 04 00 03 46 DC 02 CB 01  01 02 CC 01 00 02 CD 01  ...F............
00000050: 00 02 CF 01 00 02 D1 02  FF FF 02 D2 02 FF FF 02  ................
00000060: D3 3F 00 00 00 00 00 00  00 00 00 00 00 00 00 00  .?..............
00000070: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000080: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000090: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
000000A0: 00 02 D5 01 00 02 D6 01  01 02 D7 01 00 90 00     ...............


----- APDU command/response pair 4 -----
00000000: 80 A4 08 00 06 3F 00 30  00 C0 00                 .....?.0...

00000000: 90 00                                             ..


----- APDU command/response pair 5 -----
00000000: 00 B0 00 00 00                                    .....

00000000: 49 44 50 72 6F 74 65 63  74 20 20 20 20 20 20 20  IDProtect       
00000010: 20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20                  
00000020: 41 74 68 65 6E 61 20 53  6D 61 72 74 63 61 72 64  Athena Smartcard
00000030: 20 53 6F 6C 75 74 69 6F  6E 73 20 20 20 20 20 20   Solutions      
00000040: 49 44 50 72 6F 74 65 63  74 20 20 20 20 20 20 20  IDProtect       
00000050: 30 44 35 30 30 30 30 39  32 31 32 32 38 37 39 36  0D50000921228796
00000060: 0D 04 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000070: 00 00 00 00 10 00 00 00  04 00 00 00 FF FF FF FF  ................
00000080: 00 00 00 00 FF FF FF FF  00 00 00 00 01 00 01 00  ................
00000090: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
000000A0: 00 90 00                                          ...


----- APDU command/response pair 6 -----
00000000: 80 A4 08 00 06 3F 00 30  00 30 04                 .....?.0.0.

00000000: 6A 82                                             j.


----- APDU command/response pair 7 -----
00000000: 80 A4 08 00 08 3F 00 30  00 30 01 D0 7E           .....?.0.0..~

00000000: 6A 82                                             j.


----- APDU command/response pair 8 -----
00000000: 80 A4 08 00 08 3F 00 30  00 30 03 40 00           .....?.0.0.@.

00000000: 90 00                                             ..


----- APDU command/response pair 9 -----
00000000: 00 B0 00 02 64                                    ....d

00000000: 41 54 48 45 4E 41 53 4E  C0 AD AA 78 FC 88 42 0D  ATHENASN...x..B.
00000010: 90 00                                             ..


----- APDU command/response pair 10 -----
00000000: 80 A4 08 0C 04 3F 00 00  20 00                    .....?.. .

00000000: 62 2F 87 01 08 83 02 00  20 80 02 00 10 8A 01 04  b/...... .......
00000010: 86 0E 00 FF C0 30 00 FF  00 10 00 FF 00 10 00 00  .....0..........
00000020: 85 0F 00 01 00 00 AA 00  04 10 00 00 00 00 00 FF  ................
00000030: FF 90 00                                          ...


----- APDU command/response pair 11 -----
00000000: 80 A4 08 00 04 3F 00 00  20                       .....?.. 

00000000: 90 00                                             ..


----- APDU command/response pair 12 -----
00000000: 00 84 00 00 08                                    .....

00000000: 11 B7 B2 80 4B 17 0D A4  90 00                    ....K.....


----- APDU command/response pair 13 -----
00000000: 80 20 00 00 10 1D ED 9E  47 A8 C9 EA CE 37 82 2C  . ......G....7.,
00000010: 92 CF 07 20 2D                                    ... -

00000000: 90 00                                             ..


----- APDU command/response pair 14 -----
00000000: 80 A4 08 00 08 3F 00 30  00 30 03 40 01           .....?.0.0.@.

00000000: 90 00                                             ..


----- APDU command/response pair 15 -----
00000000: 00 B0 00 03 01                                    .....

00000000: 03 90 00                                          ...


----- APDU command/response pair 16 -----
00000000: 80 A4 08 00 08 3F 00 30  00 30 02 D0 7E           .....?.0.0..~

00000000: 6A 82                                             j.


----- APDU command/response pair 17 -----
00000000: 80 A4 08 00 08 3F 00 30  00 30 01 D0 7E           .....?.0.0..~

00000000: 6A 82                                             j.


----- APDU command/response pair 18 -----
00000000: 80 A4 08 00 06 3F 00 30  00 EE EF                 .....?.0...

00000000: 90 00                                             ..


----- APDU command/response pair 19 -----
00000000: 00 B0 00 00 00                                    .....

00000000: 02 C4 01 00 02 C7 08 32  30 31 37 30 32 32 32 90  .......20170222.
00000010: 00                                                .


----- APDU command/response pair 20 -----
00000000: 80 28 00 00 04 00 00 00  20                       .(...... 

00000000: 90 00                                             ..

\end{verbatim}
\section{C\_findObjectInit}
Place an image here of the trace
\section{C\_generateKey}
Place an image here of the trace
\section{C\_generateKeyPair}
Place an image here of the trace
\section{C\_createObject}
Place an image here of the trace
\section{C\_destroyObject}
Place an image here of the trace
\section{C\_encrypt}
Place an image here of the trace
\section{C\_decrypt}
Place an image here of the trace
\section{C\_sign}
Place an image here of the trace
\section{C\_verify}
Place an image here of the trace
\section{C\_setAttribute}
Place an image here of the trace
\section{C\_wrap / C\_unwrap}
Place an image here of the trace




%---------------------------------------------------------------------------------------------------------------------------------------------------
\chapter{Attempts To Attack At the APDU Level}


%DO NOT FORGOT!\\
%Need to mention somewhere in this section that I have tried:\\
%delaying the response to the smart-card to test for TOTP (upto 2 hours)\\
%Modified initialization data to test if there is a master key, which could be used to create a derived key to encrypt the PIN/Password.
%(there are references to papers which suggest some smart-card manufactures do this!)
\section{Reverse Engineering PIN/password Authentication}

The first attack that I decided to attempt is to reverse-engineer the PIN authentication method. The reasoning behind this is because if this can be successfully done, the PIN can then be inferred from one communication trace sniffed between smart-card and the API (on the computer). The inference comes from the fact that once the method is deduced, an attacker can simply brute force the possible combinations of a PIN, to test if a match is found. (This becomes clearer in the latter sections)

From previous work completed on this card by an MSC student last year [?], and from the analysis conducted in section 6.2, it was quite clear that the card has the following characteristics in terms of PIN authentication. The PKCS\#11 API requests a challenge, the smart-card responds with an 8 byte challenge, the API then calculates a 16 byte response (using the 8 byte challenge, and the PIN), the smart-card verifies whether or not the response is correct. There are two response formats to that  APDU verification command:
\begin{itemize}
\item '90 00' $\rightarrow$ verification succeeded, correct PIN was entered
\item '63 CX' $\rightarrow$ verification failed (where X is the number of attempts left before the card is blocked)\\
\end{itemize}

% IMAGE: challenge-response pin authentication
\begin{figure}[H]
\centering
\begin{subfigure}{1\textwidth}
  \includegraphics[width=1\linewidth]
  {images/section_7/7.1/authencation_method.png}
  \label{fig:sub1}
\end{subfigure}
\end{figure}


The following sections are explanations of the searches that we conducted to try and reverse-engineer the protocol showed above. To give a full understanding of how challenging this part of the project was, we will explain the combinations of possibilities we checked, and the reasoning behind each of them. These will be split up into different 'searches', and increment in terms of new findings and understanding of how the protocol may be implemented.

To aid these explanations, we introduce here 3 key sub-functionalities that most of the conducted searches use. Table 7.1 lists all the hash functions (see section 3.1) that were used, and provides the output length in bits \& bytes. Those hash functions were all supported by openSSL and the python package 'hashlib'. Table 7.2 provides the names of the bitwise logical operations that were used to 'join' two bytes together. And table 7.3 provides the description of truncation methods used to reduce the output size of a search down to 16 bytes to match the response provided by the API. \\

From here on, in the explanation of the searches I will just refer to HASH, JOIN \& TRUNCATE which will suggest that all of the elements in the tables have been iterated over and preformed on. For example TUNRCATE(HASH('this is a string')), means the string, 'this is a string', is to be hashed with all the functions in table 7.1, and then truncated to 16 bytes using all the methods listed in table 7.3.\\


%DSA & 0 & 0\\
%DSA-SHA & 0 & 0 \\
%dsaEncryption & 0 & 0 \\
%ecdsa-with-SHA1 & 0 & 0\\
% TABLE: Hash functions
\begin{table}[H]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Hash Name & Output Length (bits) & Output Length (Bytes)\\
\hline
MD4 & 128 & 16\\
MD5 & 128 &16\\
MDC2 & 128 & 16\\
RIPEMD160 & 160 & 20\\
SHA & 160 & 20\\
SHA1 & 160 & 20\\
SHA224 & 224 & 28\\
SHA256 & 256 & 32\\
SHA384 & 384 & 48\\
SHA512 & 512 & 64\\
WHIRLPOOL & 512 & 64\\
\hline
\end{tabular}
\caption{Hash Functions}
\end{center}
\end{table}

% TABLE: Joining Methods
\begin{table}[H]
\begin{center}
\begin{tabular}{|c|}
\hline
Logical Operations\\
\hline
AND\\
OR \\
XOR\\
NOT AND\\
NOT OR\\
NOT XOR\\
\hline
\end{tabular}
\end{center}
\caption{Bitwise Logical Operations (Joins)}
\end{table}

% TABLE: Truncation methods
\begin{table}[H]
\begin{center}
\begin{tabular}{|c|p{10cm}|}
\hline
Truncation method & Description?\\
\hline
first\_16 & Truncates the output by taking the first 16 bytes \\
last\_16 & Truncates the output by taking the last 16 bytes\\
mod\_16 & Truncates the output by taking modulus $2^{128}$ [We use 128 because that's the number of bits in 16 bytes]  \\
\hline
\end{tabular}
\end{center}
\caption{Truncation Methods}
\end{table}

\newpage


\noindent Before any searches could be conducted, the first task was to extract the values of the 8 byte challenge (denoted X), and the 16 byte response (denoted Y), from a communication trace of C\_login. Table 7.4 provides the values for the PIN, X and Y in hexadecimal format.\\

 
% TABLE: PIN, X, Y
\begin{table}[H]
\begin{center}  
\begin{tabular}{|l|c|l|}
\hline
Data & ASCII & HEX\\
\hline
PIN & '0000000000000000' & 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30\\
\hline
Y & N/A & 53 17 55 20 F4 30 18 56 80 E6 75 55 E1 91 A7 EC\\
\hline
X & N/A & 68 F1 E4 92 85 36 39 A3\\
\hline
\end{tabular}
\end{center}
\caption{}
\end{table}


In the very first original experiments, we made assumptions as did previous work on this card [ref Msc] that the PIN number was only numerical characters, only had 4-8 digits and if the PIN was less than 8 characters, it was padded using a special character to form 8 bytes. These assumptions turned out to be false, and thus the elementary experiments were all flawed from the beginning. I have not included a description of those experiments in the following sections, as many of them were in fact very similar to those explained below, just with different assumptions of the PIN. They also used a PIN for the card that was '12345', and hence there was an exponential explosion in the number of experiments for a particular search, due to needing to test for different padding schemes and characters. Hence why in these following experiments the PIN had been set to '0000000000000000' (16 zeros, no need for padding).




\subsection{Authentication Protocol Search 1.0 (Password Storage)}
Assumptions:\\
\begin{itemize}
\item PIN consists of alpha - numeric characters
\item PIN is a maximum of 16 bytes
\item PIN is encoded in ASCII characters
\item For any PIN that is less than 16 bytes long, there is padding character used to pad the PIN to 16 bytes\\
\end{itemize}

%--------------------------------------
\textbf{\underline{Search 1 - Hash functions}}\\
\noindent In this initial stages we thought that there is a large possibility that the 16 byte response was generated by hashing a combination of the PIN and the 8 byte challenge. This was partly due to common practices used in industry whereby users passwords are often hashed, and in most cases salted (see section 3.1), before storing them in databases. This practice is more secure than storing plain text passwords, as if an attacker were to gain access to the back end databases storing said passwords, the password itself would not be available to see. For authentication the password is just hashed (and salted, if a salt is used), and then compared against to the stored value. The fact that from multiple traces the 16 byte response seemed to be uniformly random, it supported this hypothesis.\\

Thus the first search that we completed focused on the fact that a hash function was used to produce the 16 byte response. Below we have listed the methods tested in expirments to generate a 16 bytes, given X and the PIN.\\

We donote $\|$ as the concatination function. Thus for two strings 'string1 ' $\|$ 'string2' = 'string1 string2'.

\textbf{\underline{Methods tested that produced a 16 byte output using X and the PIN}}
\begin{itemize}
\item join(truncate(hash(X)), pin))
\item truncate(hash(join(pin, X $\|$ X)))
\item truncate(hash(pin$\|$X))
\item truncate(hash(X$\|$pin))
\item truncate(hash(pin+X))
\item truncate(hash(join(pin, square(X))))
\end{itemize}

\textit{[The methods should be read from the most inner brackets, outward. Therefore this means that the first method dictates that X is first hashed using one of the hash functions listed in the table 7.1. The output of that is then truncated to 16 bytes using one of the functions from table 7.3. All iterations of the functions in the tables were tested.]}

The following experiment resulted in 2592 individual tests, but did not find a match to the response generated by the API [Y in table 7.4]. Thus we moved onto search 2.\\


%--------------------------------------
\textbf{\underline{Search 2 - PBKDF2}}\\
Following the failure of search 1, but still assuming there is a large possibility of a hash function being used due to the common practices mentioned in search 1, and the characteristics known so far of the 16 byte response Y. Then we decided to look at the password-based key derivation function (PBKDF2), which was created as part of PKCS \#5 by RSA laboratories [?]. It has been mentioned in literature [?], and started to be used for more secure password storage as well as for key derivation. Essentially PBKDF2 takes as input, a password (the PIN), a salt (the 8 byte challenge X), a hash function, and the number of iterative rounds. If the number of iterative round is set to 10, then the salted password would be hashed once, and the output of that would be the input for the next round of hashing. This would be completed 10 times. Literature [?] has shown that the standard for the number of iterative rounds used to be 10,000, back in 2008 (check this date). Now it is suggested to use as many rounds as is computationally feasible by the device. Due to the processing power of a smart-card I assumed that this would not exceed 100,000 rounds, in the case that PBKDF2 was used.\\

Hence this search generated experiments that ran through 1 $\rightarrow$ 100,000 rounds of PBKDF2. As the default of PBKDF2 is to truncate the output by taking the first X (X here is a variable) bytes only 'first\_16' truncation method was used.\\

\underline{\textbf{Methods tested that produced a 16 byte output using X and the PIN}}
\begin{itemize}
\item PBKDF2( hash\_function, PIN, X, number\_of\_rounds)
\end{itemize}

This generated 100,000 experiments per hash function. With 12 hash functions, this resulted in 1.2 million tests being run. Due to the sheer computational power required for this search I decided to parallelize the search based on the hash function, and run them on separate cores of a server. Even by improving the efficiency of this search, it still took 2 weeks to conduct.

Again this unfortunately did not result in a match between the 16 byte responses calculated and Y (the API's response). Hence we move onto search 3.\\

\subsection{Authentication Protocol Search 2.0 (One Time Passwords)}

%--------------------------------------
% source is OCRA!!!
\textbf{\underline{Search 3 - OCRA: OATH Challenge-Response Algorithm}}\\
With no luck of deducing the method the authentication protocol uses, we decided to look into more complex standards that exist and used in different parts of the computing industry for challenge response protocols, rather than password storage techniques. The international engineering task force (IETF) released a paper in 2011 [?]. Section 7.1 of the paper gives a one-way challenge response algorithm which fitted the characteristics of the authentication that takes between the API and the smart-card.

%Explain the one - way challenege response algorithm
Section 3.5.1 explains hash based one time passwords. But in essence HTOP is:\\
$HOTP(K,C) = Truncate(HMAC(K,C)) \& 0x7FFFFFFF$ [?-wiki ]

Still to complete.


\textbf{\underline{Search 4 - TOTP}}\\
With the above in mind, I also wanted to rule out TOTP. This was completed by halting communication between the smart-card and API using the man-in-the-middle tool (see section 4.2). I did this for upto 2 hours. We were looking for a failed verifaction, despite having the correct PIN. The failure should have been caused by the delay in the response if TOTP was used. This was not found and therefore ruled out the possibility of TOTP. 

This section will be explained better, and will also include reasoning behind why TOTP is not often used (time sync problems). \\



\subsection{Authentication Protocol Search 3.0 (Triple DES Encryption)}

Need to explain multiple logins and the characteristics found!\\
That lead me to believe DES3 encryption was used. Tabulate and cross out other possibilites!

%Note there are 4 more searches conducted that included the use of block ciphers.\\
%After that I will move onto explain how I thought there was a possibility of the use of a derived key from a globally known master key (this is due to a paper I read, on zero knowledge protocols). And hence used MiTM tool to change the serial number of the smart-card to see if an incorrect response would be produced by the API, despite having the correct PIN.\\
%
%Finally I will explain the 4 charactersistics I found by verifying with the card one after the other very quickly\\
%let Y = Y1 $\|$ Y2\\
%same PIN and X: same Y1 and Y2\\
%same PIN, different X: same Y1 different Y2\\
%different PIN, same X \& different PIN and different X: different Y1 and different Y2\\
%
%These characteristics are only present if the 'logins' happen within the same second. If the second changes then we have a different Y for the same PIN and same X. This suggests the use of a nonce (calculated by API on the computer), as well as X. My assumption is:  encrpyt(nonce$\|$X) [using a block cipher the PIN is the password]


\textbf{\underline{Search 5}}\\
Need to decrypt two different encryptions with different PINs in order to find out if this is the method used!\\
Raw ASCII password and MD5 hash (due to output size = 16 bytes)\\
DES3-ECB $\rightarrow$ encrypt ( Na $\|$ Vac)

\textbf{\underline{Search 6}}\\









\section{Altering File Control Parameters for Login Retry Couner}

\section{Block Cipher Injection (MiTM)}
\begin{verbatim}
template = (\\
	(CKA\_CLASS, LowLevel.CKO\_SECRET\_KEY), [private, public, data, cert (X.509)]
	(CKA\_KEY_TYPE, LowLevel.CKK_DES), [AES,DES,RSA,ECC]
	(CKA\_LABEL, label), [name]
	(CKA\_ID, chr(id)), [id]
	(CKA\_PRIVATE, True), [requires authentication]
	(CKA\_SENSITIVE, True), [cannot be extracted unencrypted]
	(CKA\_ENCRYPT, True), [can be used for encrypting data]
	(CKA\_DECRYPT, True), [can be used for decrypting data]
	(CKA\_SIGN, True), [[can be used for signing data]
	(CKA\_VERIFY, True), [can be used for verifiying data]
	(CKA\_TOKEN, True), [can be stored permanently on the device]
	(CKA\_WRAP, True), [can encrypt a key to be extracted]
	(CKA\_UNWRAP, True), [can decrypt an encrypted key]
	(CKA\_EXTRACTABLE, False)) [is allowed to be extracted from the device]
\end{verbatim}

Problem 1:\\
I inject my own RSA-2048 public key (only the public modulus part, the injected key has the same public exponent 9 bytes).\\
When secure messaging is starting to open straight after the communiacation of the injected key SEG\_FAULT!
Back to square 1, do not know what the key is.

\section{Altering Key Object Attributes}
- MSC's work

\section{Using Key's without Authentication}
- MSC's work
- there is an attribute that should prevent this!

%---------------------------------------------------------------------------------------------------------------------------------------------------
\chapter{Conclusion / Results}

This shall summarise the whole report and my findings in regard to low-level vulnerabilities on the card. 



%---------------------------------------------------------------------------------------------------------------------------------------------------
% use the following and \cite{} as above if you use BibTeX
% otherwise generate bibtem entries
\bibliographystyle{plain}
%\bibliography{mybib}
\begin{thebibliography}{}

%-------------------------------------------------------------------------------
% EXAMPLES!!
\bibitem{latexcompanion} 
Michel Goossens, Frank Mittelbach, and Alexander Samarin. 
\textit{The \LaTeX\ Companion}. 
Addison-Wesley, Reading, Massachusetts, 1993.
 
\bibitem{einstein} 
Albert Einstein. 
\textit{Zur Elektrodynamik bewegter K{\"o}rper}. (German) 
[\textit{On the electrodynamics of moving bodies}]. 
Annalen der Physik, 322(10):891â€“921, 1905.
 
\bibitem{knuthwebsite} 
Knuth: Computers and Typesetting,
\\\texttt{http://www-cs-faculty.stanford.edu/\~{}uno/abcde.html}
%------------------------------------------------------------------------------

\bibitem{virtual smartcard}
Frank Morgner : Creating a Virtual Smart Card\\
\texttt{https://frankmorgner.github.io/vsmartcard/virtualsmartcard/README.html}\\
%\href{https://frankmorgner.github.io/vsmartcard/virtualsmartcard/README.html}{link}

\bibitem{OCRA}
Internet Engineering Task Force (IETF).\\
\textit{OCRA: OATH Challenge-Response Algorithm}, June 2011\\
\texttt{https://tools.ietf.org/html/rfc6287}


\end{thebibliography}
\end{document}
%\grid
