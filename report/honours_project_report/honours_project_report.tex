
% to choose your degree
% please un-comment just one of the following
\documentclass[bsc,frontabs,twoside,singlespacing,parskip,deptreport]{infthesis}     % for BSc, BEng etc.
% \documentclass[minf,frontabs,twoside,singlespacing,parskip,deptreport]{infthesis}  % for MInf

\usepackage{pdfpages}
\usepackage{float}% If comment this, figure moves to Page 2
\usepackage{subcaption}
\usepackage{tabulary}
%\usepackage{hyperref}


\begin{document}

\title{Finding Vulnerabilities in Low-Level Protocols}

\author{Nordine Saadouni}

% to choose your course
% please un-comment just one of the following
%\course{Artificial Intelligence and Computer Science}
%\course{Artificial Intelligence and Software Engineering}
%\course{Artificial Intelligence and Mathematics}
%\course{Artificial Intelligence and Psychology }   
%\course{Artificial Intelligence with Psychology }   
%\course{Linguistics and Artificial Intelligence}    
\course{Computer Science}
%\course{Software Engineering}
%\course{Computer Science and Electronics}    
%\course{Electronics and Software Engineering}    
%\course{Computer Science and Management Science}    
%\course{Computer Science and Mathematics}
%\course{Computer Science and Physics}  
%\course{Computer Science and Statistics}    

% to choose your report type
% please un-comment just one of the following
%\project{Undergraduate Dissertation} % CS&E, E&SE, AI&L
%\project{Undergraduate Thesis} % AI%Psy
\project{4th Year Project Report}

\date{\today}


\abstract{
Basic example of an abstract (this will be changed)\\

Smart cards are used commercially and within industry for authentication, encryption, decryption, signing and verifying data. This paper aims to look into how the smart card interacts with an application at the lower level. PKCS\#11 (public key cryptography system?) is the standard that is implemented at the higher level and then broken down into command/response pairs sent as APDU traffic to and from the smart card. It is the APDU low-level protocol that will be analysed to see if any vulnerabilities are present with regard to the smart cards tested.\\
}

\maketitle


\section*{Acknowledgements}
Acknowledgements go here.
% Myrto, Andriana, Parents
% MSC student? 

\tableofcontents

%\pagenumbering{arabic}

%---------------------------------------------------------------------------------------------------------------------------------------------------

\chapter{Introduction}
Smart-cards are formally known as integrated circuit cards (ICC), and are universally thought to be secure, tamper-resistant devices. They store and process, cryptographic keys, authentication and user sensitive data. They are utilised to preform operations where confidentiality, data integrity and authentication are key to the security of a system.\\

\noindent Smart-cards offer what seems to be more secure methods for using cryptographic operations. (And should still provide the same level of security that would be offered to un-compromised systems, compared to those that are compromised by an attacker). This is partly due to the fact that the majority of modern smart-cards have their own on-board micro-controller, to allow all of these operations to take place on the card itself, with keys that are unknown to the outside world and stored securely on the device. Meaning the only actor that should be able to preform such operations would need to be in possession of the smart-card and the PIN/password. In many industries, for applications such as, banking/ payment systems, telecommunications, healthcare and public sector transport, 
%\begin{itemize}
%\item Banking/ payment
%\item E-commerce
%\item Sim cards/ telecommunications
%\item Healthcare
%\item Public transport
%\end{itemize}
smart-cards are used due to the security they are believed to provide.\\


\noindent The most common API (application programming interface) that is used to communicate with smart-cards is the RSA defined PKCS\#11 (Public Key Cryptography Standard). Also known as 'Cryptoki' (cryptographic token interface, pronounced as 'crypto-key'). The standard defines a platform-independent API to smart-cards and hardware security modules (HSM). PKCS\#11 originated from RSA security, but has since been placed into the hands of OASIS PKCS\#11 Technical Committee to continue its work (since 2013). [reference wikipedia PKCS\#11].\\


% Note: decide on a figure to use here, 10 OR 15 years!
% This paragraph needs to be re-written!
\noindent In the previous 10-15 years, literature has shown a great deal of research has examined the PKCS\#11 API. But not much attention has been paid to that of the lower-level communication, in which the higher level API is broken down into. This is analogous to C code being complied down to binary data to be operated on by the CPU. In the same context, a PKCS\#11 function cannot be considered 'secure' without its corresponding APDU command/response pairs also being considered 'secure'. Much like the addition of two integers cannot be considered to be correct in a higher level lanugage such as C, unless the corresponding binary instructions sent to the CPU are correct as well. 

%---------------------------------------------------------------------------------------------------------------------------------------------------

\chapter{Background}

\section{PKCS\#11}

\subsection{Key Object}
\subsection{Attributes}
\subsection{Most Common Functions}


\section{ISO 7816}

\subsection{Command Structure}
\subsection{Response Structure}
\subsection{Inter-Industry/ Proprietary}
\subsection{Most Common Commands}
\subsection{File Structure}





%---------------------------------------------------------------------------------------------------------------------------------------------------

\chapter{Cryptographic Operations}

\section{Hash Function}

\noindent explain this in an overview term



\section{Asymmetric Encryption}

\noindent explain this in an overview term

\subsection{RSA}

\section{Symmetric Encryption}

\noindent explain this in an overview term

\subsection{DES}
\subsection{Triple DES}
\subsection{AES}

% might go against those headings and just list them in the explanations
\subsection{ECB Mode}
\subsection{CBC Mode}


\section{MAC}

\noindent explain what a message authentication code is, what its used for\\
\noindent (wikipedia have good diagrams and explanations of this!!)

\subsection{HMAC}
\subsection{CMAC}

\section{OTP}

\noindent What is a one time password $\rightarrow$ what forms are there?

\subsection{HOTP}
\subsection{TOTP}




%---------------------------------------------------------------------------------------------------------------------------------------------------

\chapter{Tools}

\section{PCSC}

\section{Virtual Smart-Card}

\section{Parsing?}






%---------------------------------------------------------------------------------------------------------------------------------------------------

\chapter{Related Work / Literature Review}

This will be a brief chapter and will discuss all of the research I have conducted.\\
Mainly regarding PKCS\#11 API attacks due to the small amount of literature that is available for APDU level attacks
I shall also explain why some of the attacks are not able to be conducted on the particular card I am reviewing






%---------------------------------------------------------------------------------------------------------------------------------------------------

\chapter{PKCS\#11 Functions - APDU analysis}

Here I shall simply give a trace of each PKCS\#11, and give an analysis of each trace

\section{Initialization?}
Might be worth separating these!
\section{C\_login}
Place an image here of the trace
\section{C\_findObjectInit}
Place an image here of the trace
\section{C\_generateKey}
Place an image here of the trace
\section{C\_generateKeyPair}
Place an image here of the trace
\section{C\_createObject}
Place an image here of the trace
\section{C\_destroyObject}
Place an image here of the trace
\section{C\_encrypt}
Place an image here of the trace
\section{C\_decrypt}
Place an image here of the trace
\section{C\_sign}
Place an image here of the trace
\section{C\_verify}
Place an image here of the trace
\section{C\_setAttribute}
Place an image here of the trace
\section{C\_wrap / C\_unwrap}
Place an image here of the trace




%---------------------------------------------------------------------------------------------------------------------------------------------------
\chapter{Attempts To Attack At the APDU Level}

This will be the description of the attacks I have attempted, and most likely mentioned during the analysis from the previous chapter\\

\section{Reverse Engineering PIN/password Authentication}
The first attack that I decided to attempt is to reverse-engineer the PIN/password authentication method. The reasoning behind this is because if this can be successfully done, the PIN/password can then be inferred from one communication trace sniffed between the computer using the smart-card and the smart-card itself. The inference comes from the fact that once the method is deduced, an attacker can simply brute force the possible combinations of a PIN/password, and run them through the 'method' that has been reversed engineered to see if a matching response is found. If so, then the PIN is that of the matching response.

From previous work completed on this card by an MSC student last year [?], and from the analysis conducted in section 6.2, it was quite clear that the card has the following characteristics in terms of PIN/password authentication. The 'middleware'/API requests a challenge, the smart-card responds with an 8 byte challenge, the API then calculates a 16 byte response, the smart-card verifies whether or not the response is correct. There are two response formats to that verification:
\begin{itemize}
\item '90 00' $\rightarrow$ verification succeeded, correct PIN/password was given
\item '63 CX' $\rightarrow$ verification failed (where X is the number of attempts left before the card is blocked)\\
\end{itemize}

\begin{figure}[H]
\centering
\begin{subfigure}{1\textwidth}
  \includegraphics[width=1\linewidth]
  {images/section_7/7.1/authencation_method.png}
  \label{fig:sub1}
\end{subfigure}
\end{figure}


%DO NOT FORGOT!\\
%Need to mention somewhere in this section that I have tried:\\
%delaying the response to the smart-card to test for TOTP (upto 2 hours)\\
%Modified initialization data to test if there is a master key, which could be used to create a derived key to encrypt the PIN/Password.
%(there are references to papers which suggest some smart-card manufactures do this!)


Initially it was assumed that the PIN number consisted only of numbers, and was between 4-8 digits long. This assumption was found to be incorrect, however the assumption is key to the explanation of the following section (authentication protocol search 1.0), as it supports the reasoning behind the initial attempts made to reverse-engineer the authentication protocol. \\

\subsection{Authentication protocol search 1.0}
Assumptions:\\
\begin{itemize}
\item PIN consists of only numerical digits
\item PIN is a maximum of 8 bytes
\item PIN is encoded in ASCII characters
\item For any PIN that is less than 8 bytes long, there is padding character used to pad the PIN to 8 bytes
\end{itemize}

The following subsections are explanations of the searches conducted under the assumptions listed above, in order to try and find the method used in calculating the response to be verified using the password and the 8 byte challenge. To give a full understanding of how challenging this part of the project was I will give a brief explanation of the code that runs through different combinations of possibilities for the challenge-response protocol.

\noindent Before any searches could be conducted, the first task was to extract the values of the 8 byte challenge (denoted X), and the 16 byte response (denoted Y), from a communication trace of C\_login. Tabulated below are the values for the PIN, X and Y in different formats. Hexadecimal is the format used in the communication between smart-card and PC which is why this formatting is also provided. 
%(comparisons of results were often in HEX?) 

\begin{center}
\begin{tabular}{|l|c|p{5cm}|p{5cm}|}
\hline
Data & ASCII & DEC & HEX\\
\hline
PIN & '12345' & 49 50 51 52 53 & 31 32 33 34 35\\
\hline
X & N/A & 41 199 41 31 237 19 35 123 & 29 C7 29 1F ED 13 23 7B\\
\hline
Y & N/A & 174 105 184 75 125 190 187 43 99 99 211 125 7 157 211 236 & AE 69 B8 4B 7D BE BB 2B 63 63 D3 7D 07 9D D3 EC\\
\hline
\end{tabular}
\end{center}


% I think this could be worded better, but it will do for now.
\subsection{Search 1.1}
\noindent In this initial stages we thought that there is a large possibility that the 16 byte response was generated by hashing a combination of the PIN and the 8 byte challenge. This was partly due to common practices used in industry whereby users passwords are often hashed, and in most cases salted (see section 3.1), before storing them in databases. This practice is more secure than storing plain text passwords, as if an attacker were to gain access to the back end databases storing said passwords, the password itself would not be available to see. For authentication the password is just hashed (and salted, if a salt is used), and then compared against to the stored value.\\

\noindent Thus the first search that we completed focused on the possibility the PIN and 8 byte challenge were joined (either before or after hashing) using some bitwise operation, and hashed to generate a response which would then be truncated down to 16 bytes.



% TABLES
% hash function table that was searched
\begin{center}
\begin{tabular}{|l|r|}
\hline
Hash Name & Output Length\\
\hline
SHA256 & 0 \\
SHA512 & 0 \\
dsaWithSHA & 0 \\
mdc2 & 0 \\
SHA224 & 0 \\
MD4 & 0 \\
sha256 & 0 \\
sha512 & 0 \\
ripemd160 & 0 \\
whirlpool & 0 \\
SHA1 & 0 \\
MDC2 & 0 \\
SHA & 0 \\
SHA384 & 0 \\
ecdsa-with-SHA1 & 0 \\
md4 & 0 \\
md5 & 0 \\
sha1 & 0 \\
DSA-SHA & 0 \\
sha224 & 0 \\
dsaEncryption & 0 \\
DSA & 0 \\
RIPEMD160 & 0 \\
sha & 0 \\
MD5 & 0 \\
sha384 & 0 \\
\hline
\end{tabular}
\end{center}

% bitwise operation table that was used
\begin{center}
\begin{tabular}{|l|r|}
\hline
Bitwise Operation & Description?\\
\hline
AND & --\\
OR & -- \\
XOR & --\\
NAND & -- \\
NOR & -- \\
NXOR & -- \\
\hline
\end{tabular}
\end{center}

% truncation options that were used (first 16, last 16, modulous outout)
\begin{center}
\begin{tabular}{|l|r|}
\hline
Truncation method & Description?\\
\hline
First 16 & --\\
Last 16 & --\\
Mod & --\\
\hline
\end{tabular}
\end{center}


% To complete tomorrow:
% Fill in the tables with accurate information
% Explain the all of authentication protocol search 1.0 at the least!
% Consider mobing tables to be at the start of the section (chapter) as to allow reference in later sections!



method 1:\\
HASH(X) -> 16 bytes, join(HASH(X), pin)\\

method 2:\\
HASH(join(pin , X||X)), reduce to 16 bytes\\\\

method 3:\\
salt pin with X (pin comes first), hash salted pin\\\\

method 4:\\
salt pin with X (X comes first), hash salted pin\\\\

method 5:\\
format pin to integer, pin += random number (from get challenge), hash(all)\\\\

method 6:\\
square(X) (creates 16 bytes), join(pin, square(x)), hash(all)\\\\
% because $(2^(8*16))^2 == 2^16*16$

iterate through:\\
methods 1 $\rightarrow$ 6\\
padding methods (pad at end, pad at start)\\
padding character used (0 $\rightarrow$ 255)\\
hash used\\
join method (xor, nxor, and, nand, or, nor)\\
truncate output to 16 bytes using one of the following functions (start 16, last 16, mod output)\\



\subsection{Search 1.2}
\subsection{Search 1.3}


\subsection{Authentication protocol search 2.0}




%---------------------------------------------------------------------------------------------------------------------------------------------------
\chapter{Conclusion / Results}

This shall summarise the whole report and my findings in regard to low-level vulnerabilities on the card.



%---------------------------------------------------------------------------------------------------------------------------------------------------
% use the following and \cite{} as above if you use BibTeX
% otherwise generate bibtem entries
\bibliographystyle{plain}
%\bibliography{mybib}
\begin{thebibliography}{}

%-------------------------------------------------------------------------------
% EXAMPLES!!
\bibitem{latexcompanion} 
Michel Goossens, Frank Mittelbach, and Alexander Samarin. 
\textit{The \LaTeX\ Companion}. 
Addison-Wesley, Reading, Massachusetts, 1993.
 
\bibitem{einstein} 
Albert Einstein. 
\textit{Zur Elektrodynamik bewegter K{\"o}rper}. (German) 
[\textit{On the electrodynamics of moving bodies}]. 
Annalen der Physik, 322(10):891–921, 1905.
 
\bibitem{knuthwebsite} 
Knuth: Computers and Typesetting,
\\\texttt{http://www-cs-faculty.stanford.edu/\~{}uno/abcde.html}
%------------------------------------------------------------------------------

\bibitem{virtual smartcard}
Frank Morgner : Creating a Virtual Smart Card\\
\texttt{https://frankmorgner.github.io/vsmartcard/virtualsmartcard/README.html}\\
%\href{https://frankmorgner.github.io/vsmartcard/virtualsmartcard/README.html}{link}

\bibitem{OCRA}
Internet Engineering Task Force (IETF).\\
\textit{OCRA: OATH Challenge-Response Algorithm}, June 2011\\
\texttt{https://tools.ietf.org/html/rfc6287}


\end{thebibliography}
\end{document}
%\grid
